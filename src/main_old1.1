#[derive(Debug)]
enum VarOrTerm{
    Var(String),
    Term(String)
}

#[derive(Debug)]
struct Triple{
    s: VarOrTerm,
    p: VarOrTerm,
    o: VarOrTerm
}
#[derive(Debug)]
struct Rule{
    head: Triple,
    body: Triple
}
#[derive(Debug)]
struct Store{
    triples: Vec<Triple>
}
struct Solutions {
    variables: Vec<VarOrTerm::Var>,
    values: Vec<Vec<VarOrTerm::Term>>,
}
struct Binding{
    variable: &'static String,
    value: &'static String,
}
impl Store{
    fn new() -> Store{
        Store{triples: Vec::new()}
    }
    fn add(&mut self, triple:Triple){
        self.triples.push(triple);
    }
    fn matchTerm(queryEl: &VarOrTerm, tripleEl: &VarOrTerm) ->Option<Binding>{
        if let VarOrTerm::Term(sTerm) = tripleEl{
            match queryEl{
                VarOrTerm::Var(s) => Option(Binding{ variable:  s, value: sTerm}),
                VarOrTerm::Term(s) if s.eq(sTerm)=> Option(Binding{ variable:  s, value: sTerm}),
                _ => None
            }

        }else{
            None
        }

    }
    fn queryTP(&self, query:&Triple) -> Vec<&Triple>{
        let mut matches = Vec::new();
        for triple in self.triples.iter(){
            let mut matchQuery = true;
            if let Triple{s:sVar,o:oVar, p:pVar} = triple {
                matchQuery= Store::matchTerm(&query.s,sVar);
                matchQuery&= Store::matchTerm(&query.p,pVar);
                matchQuery&= Store::matchTerm(&query.o,oVar);
            }
            if matchQuery{
                matches.push(triple);
            }
        }
        matches
    }
    fn materialize(&self, rules: Vec<Rule>){
        for rule in rules.iter(){
            let matches = self.queryTP(&rule.body);
            println!("{:?},", matches);
        }
    }
}
fn main(){
    use VarOrTerm::{Var, Term};
    let triple = Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Term(String::from("o"))};
    println!("{:?}",triple);
    let mut tripleStore = Store::new();
    tripleStore.add(triple);
    println!("{:?}",tripleStore);
    tripleStore.add(Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Term(String::from("o2"))});
    println!("{:?}",tripleStore);
    let matches = tripleStore.queryTP(&Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Var(String::from("?o"))});
    println!("Matches {:?}",matches);
    let mut rules = Vec::new();
    tripleStore.add(Triple{s:Term(String::from("s")), p:Term(String::from("a")), o:Term(String::from("C1"))});

    rules.push(Rule{body: Triple{s:Var(String::from("s")), p:Term(String::from("a")), o:Term(String::from("C1"))},
                          head: Triple{s:Var(String::from("s")), p:Term(String::from("a")), o:Term(String::from("C2"))}});
    tripleStore.materialize(rules);

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tp_query_test() {
        use VarOrTerm::{Var, Term};
        let mut tripleStore = Store::new();

        tripleStore.add(Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Term(String::from("o"))});
        tripleStore.add(Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Term(String::from("o2"))});
        let matches = tripleStore.queryTP(&Triple{s:Term(String::from("s")), p:Term(String::from("p")), o:Var(String::from("?o"))});

        assert_eq!(2, matches.len());
    }
}